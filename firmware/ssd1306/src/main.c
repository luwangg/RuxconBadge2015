#include <string.h>
#include "stm32f0xx_conf.h"
#include "i2c_func.h"
#include "u8g_arm.h"

//#include "stm32f0xx_type.h"
//#include "stm32f0xx_rcc.h"
//#include "stm32f0xx_gpio.h"
//#include "stm32f0xx_usart.h"
//#include "stm32f0xx_i2c.h"

#define threatbutt_width 64
#define threatbutt_height 64
static unsigned char threatbutt_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xc0, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x07,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x1f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x1e, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xfc, 0xef, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xf7, 0x3a,
   0x00, 0x00, 0x1e, 0x00, 0x00, 0xd6, 0xfb, 0x3c, 0x00, 0x00, 0xe1, 0x00,
   0x00, 0xbe, 0x7b, 0x3c, 0x00, 0x00, 0x01, 0x07, 0x00, 0xaf, 0x7f, 0x3a,
   0x00, 0x00, 0x01, 0x08, 0x80, 0xcf, 0x2b, 0x7f, 0x00, 0x00, 0x29, 0x08,
   0x80, 0xef, 0xfb, 0x7b, 0x00, 0x80, 0x00, 0x09, 0x80, 0xe7, 0xcf, 0x76,
   0x00, 0x80, 0x10, 0x09, 0x00, 0xfb, 0x7f, 0x73, 0x00, 0x80, 0x44, 0x09,
   0x00, 0xf3, 0xcf, 0xfc, 0x00, 0x40, 0x10, 0x05, 0x00, 0xff, 0x3d, 0x9e,
   0x00, 0x40, 0x82, 0x04, 0x00, 0x7e, 0xc7, 0x87, 0x00, 0x40, 0xa8, 0x04,
   0x00, 0xc6, 0xf1, 0x80, 0x01, 0x20, 0x82, 0x02, 0x00, 0x3c, 0x7e, 0x00,
   0x01, 0x20, 0x50, 0x02, 0x00, 0xe2, 0x07, 0x00, 0x03, 0x3e, 0x45, 0x02,
   0x00, 0xfe, 0x01, 0x14, 0x82, 0x21, 0x50, 0x01, 0x00, 0x3e, 0x00, 0x24,
   0x66, 0x10, 0x22, 0x01, 0x00, 0x04, 0x00, 0x20, 0x24, 0xf0, 0x27, 0x01,
   0x00, 0x04, 0x00, 0x28, 0x9c, 0x0f, 0x3c, 0x01, 0x00, 0x04, 0x00, 0x48,
   0x08, 0x06, 0xb0, 0x00, 0x00, 0x04, 0x00, 0x40, 0x48, 0x01, 0xa0, 0x00,
   0x00, 0x08, 0x00, 0x50, 0x90, 0x00, 0xc0, 0x00, 0x00, 0x08, 0x00, 0x50,
   0x80, 0x00, 0x40, 0x00, 0x00, 0x08, 0x00, 0x90, 0x00, 0x10, 0x40, 0x00,
   0x00, 0x08, 0x00, 0xa0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x10, 0x00, 0xa0,
   0x00, 0x00, 0x40, 0x00, 0x00, 0x20, 0x00, 0x20, 0x07, 0x00, 0x40, 0x00,
   0x00, 0x20, 0x00, 0x20, 0x10, 0x00, 0x20, 0x00, 0x00, 0x40, 0x00, 0x20,
   0x1f, 0x10, 0x20, 0x00, 0x00, 0xc0, 0x00, 0xe0, 0x02, 0x20, 0x30, 0x00,
   0x00, 0x80, 0x00, 0x80, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x60,
   0x03, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0c, 0x00,
   0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00,
   0x00, 0xa0, 0x01, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x70, 0x00, 0x00,
   0x00, 0x00, 0x30, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00,
   0x80, 0x25, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0xe8, 0x24, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xfc, 0x1f, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
   0x80, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xc0, 0x4e, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xa0, 0xc0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
   0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x8e, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xa2, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x80, 0xad,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb1, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00 };

uint32_t timercounter = 0;

int i = 0;
u8g_t u8g; 

GPIO_InitTypeDef GPIOC_InitStruct = {
    .GPIO_Pin = GPIO_Pin_All,
    .GPIO_Speed = GPIO_Speed_2MHz,
    .GPIO_Mode = GPIO_Mode_OUT
};

GPIO_InitTypeDef GPIOA_InitStruct = {
    .GPIO_Pin = GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10,
    .GPIO_Speed = GPIO_Speed_50MHz,
    .GPIO_Mode = GPIO_Mode_OUT,
    .GPIO_OType = GPIO_OType_PP,
    .GPIO_PuPd = GPIO_PuPd_NOPULL
};

//GPIO_InitTypeDef GPIOB_InitStruct = {
//    .GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7,
//    .GPIO_Speed = GPIO_Speed_2MHz,
//    .GPIO_Mode = GPIO_Mode_AF,
//    .GPIO_OType = GPIO_OType_OD,
//    .GPIO_PuPd = GPIO_PuPd_UP
//};



USART_InitTypeDef USART2_InitStruct;

void USART2_IRQHandler(void){
    GPIO_WriteBit(GPIOC, GPIO_Pin_9, Bit_SET);
};

void SysTick_Handler(void) {
    timercounter++;
}

void draw(uint8_t pos)
{
  //u8g_SetFont(&u8g, u8g_font_unifont);
  //u8g_DrawStr(&u8g,  5, 12+pos, "Fuck You");
  //u8g_DrawBox(&u8g, 1,1+pos,100,100);
  u8g_DrawXBM(&u8g, pos,0, threatbutt_width, threatbutt_height, threatbutt_bits);
}

int main(void)
{
    //RCC_ClocksTypeDef Clocks;
    uint8_t pos = 0;
     
    SystemInit();
    SystemCoreClockUpdate(); //update the system clock variable
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
    GPIO_Init(GPIOA, &GPIOA_InitStruct);
     
    timercounter = 0;
    //set systick to 1 every 1uS 
    SysTick_Config(SystemCoreClock/8);
    
    GPIO_SetBits(GPIOA, GPIO_Pin_10);

    //init_i2c();
    //I2C_TransferHandling(I2C1, 0x78, 0, I2C_Reload_Mode, I2C_Generate_Stop | I2C_Generate_Start_Write);
    
    static BitAction toggle = Bit_SET;
    //I2C_SlaveAddressConfig(I2C1, 0x78); 
    
    //I2C_MasterRequestConfig(I2C1, I2C_Direction_Transmitter);
    int i =0;
    //init_i2c(); 
    //I2C_WrReg(0x80, 0xAE);
    //I2C_WrReg(0x80, 0x8D);
    //I2C_WrReg(0x80, 0x14);
    //I2C_WrReg(0x80, 0xAF); 
    
    //init the u8g library
    u8g_InitComFn(&u8g,  &u8g_dev_ssd1306_128x64_i2c, u8g_com_hw_i2c_fn);
    //u8g_Begin(&u8g); 
    u8g_SetDefaultForegroundColor(&u8g);
    //u8g_SetDefaultBackgroundColor(&u8g);

   
    //while(1){
    for(;;){
         u8g_FirstPage(&u8g);
         do
         {
           draw(pos);
         } while ( u8g_NextPage(&u8g) );
         
         /* refresh screen after some delay */
         u8g_Delay(100);
         
         /* update position */
         pos++;
         //pos &= ;     
        //while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY) == SET);

        //I2C_TransferHandling(I2C1, 0x78, 2, I2C_Reload_Mode, I2C_Generate_Start_Write);
        ////while(I2C_GetFlagStatus(I2C1, I2C_ISR_TXIS) == RESET);
        ////I2C_SendData(I2C1, 0x78);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_TXIS) == RESET)I2C_SendData(I2C1, 0x80);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_TCR) == RESET);
        //I2C_SendData(I2C1, 0xAE);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_STOPF) == RESET);
        //I2C_ClearFlag(I2C1, I2C_ICR_STOPCF);
        //I2C_TransferHandling(I2C1, 0x78, 2, I2C_Reload_Mode, I2C_Generate_Start_Write);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_TXIS) == RESET);
        //I2C_SendData(I2C1, 0x78);
        //while(I2C_GetFlagStatus(I2C2, I2C_ISR_TXIS) == RESET);
        //I2C_SendData(I2C1, 0x80);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_TCR) == RESET);
        //I2C_SendData(I2C1, 0x8D);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_STOPF) == RESET);
        //I2C_ClearFlag(I2C1, I2C_ICR_STOPCF);

        //while(I2C_GetFlagStatus(I2C2, I2C_ISR_TXIS) == RESET);
        //I2C_SendData(I2C1, 0x80);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_TCR) == RESET);
        //I2C_SendData(I2C1, 0x14);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_STOPF) == RESET);
        //I2C_ClearFlag(I2C1, I2C_ICR_STOPCF);

        //while(I2C_GetFlagStatus(I2C2, I2C_ISR_TXIS) == RESET);
        //I2C_SendData(I2C1, 0x80);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_TCR) == RESET);
        //I2C_SendData(I2C1, 0xAF);
        //while(I2C_GetFlagStatus(I2C1, I2C_ISR_STOPF) == RESET);
        //I2C_ClearFlag(I2C1, I2C_ICR_STOPCF);

 //while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
    //overflow the buffer 
    /* While the bus is busy */
        //while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
    
    /* Send START condition */

        /* Test on EV8 and clear it */
    //while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));

  /* Send STOP condition */
                  //    GPIO_WriteBit(GPIOC, GPIO_Pin_8, Bit_SET);
      //    USART_SendData(USART2, 'X'); 
      //  }
      //while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == SET){
        //overflowbuffer[i++] = (char)USART_ReceiveData(USART2);
        //USART_SendData(USART2, 'X');
        //GPIO_WriteBit(GPIOC, GPIO_Pin_8, toggle);
        //if(toggle == Bit_SET) toggle = Bit_RESET;
        //else toggle = Bit_SET;
        //}
            //    GPIO_WriteBit(GPIOC, GPIO_Pin_8, Bit_SET);
      //    USART_SendData(USART2, 'X'); 
      //  }
      //GPIO_WriteBit(GPIOC, GPIO_Pin_8, toggle);
      //    if(toggle == Bit_SET){
      //      toggle = Bit_RESET;
      //  }
      //    else {
      //      toggle = Bit_SET;
      //    }
        //USART_ClearFlag(USART1, USART_FLAG_RXNE);
    }
}
#ifdef __CC_ARM
// retarget fputc()
int fputc(int c, FILE *stream) {
    return (int)ITM_SendChar((uint32_t)c);
}
#endif
